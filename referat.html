<!DOCTYPE html>
<html>
    <head> 
      <meta name="author" content="vmarkova"/>
      <meta name="keywords" content="fetch API, XMLHttpRequests, pros and cons, Promises, introduction, Response, synchronous and asynchronous"/>
      <meta name="description" content="What is HTML and which are its basic elements"/>
      
      <link href="styling/styling.css" rel="stylesheet"></link>

      <link href = "images/fetch.jpeg" rel="icon" type="image/jpeg">

      <title>Fetch API and XHR</title>
    </head>

    <body>
        <div class="navigation">
            <ul class="navigation">
				<li>
					<a href="#top"><h2 class="navigation">Начало</h2></a></li>
                <li>
					<a href="#calls"><h2 class="navigation">Синхронни и асинхронни извиквания</h2></a></li>  
                <li>
                    <a href="#xhr"><h2 class="navigation">XHR</h2></a></li>  
                <li>
                    <a href="#ajax"><h3 class="navigation">Преди и след AJAX</h3></a></li>
                <li>
                <li>
                    <a href="#callbacks"><h3 class="navigation">Callback функции</h3></a></li>
                <li>
                    <a href="#fetchapi"><h2 class="navigation">Fetch API</h2></a></li>
                <li>
                    <a href="#promises"><h3 class="navigation">Promises</h3></a></li>
                <li>
                    <a href="#asyncawait"><h3 class="navigation">Async/Await</h3></a></li>
                <li>
                    <a href="#ъдхъвкясдх"><h2 class="navigation">Обобщение</h2></a></li>
                <li>
					<a href="#sources"><h2 class="navigation">Използвана литература</h2></a></li>
				<li>
					<a href="#author"><h2 class="navigation">Автор</h2></a></li>
            </ul>
        </div>
        <div class="main">
            <h1>Fetch API and XHR (vs.?)</h1>
            <article id="calls">
                <h2>Синхронни и асинхронни извиквания</h2> 
                <p>Много важно е да знаем разликата между синхронни и асинхронни извиквания, както и кога, какво и как да използваме. 
                    <h3><strong>Синхронни заявки</strong></h3>
                    Както се подразбира от името, синхронни означава, че се изпълняват в някаква последователност, тоест всеки statement в даден код
                    се изпълнява след този преди него, трябва да се изчака предният да е завършил, за да бъде изпълнен текущият.
                </p>
 <pre>
    document.write("Hello,"); // First  

    document.write("You") ;// Second 
                                        
    document.write("New bill to pay!"); // Third 
</pre>
<figcaption>
    <span class="fig_cap_label">Пр. код 1.</span>
    <span class="fig_cap_text">Отпечатване[<a href="#sources">7</a>]</span>
</figcaption>  

                <pre>
                <script> 
                    document.write("<br>"); 
                    document.write("Hello,"); // First
                    document.write("<br>"); 
                    document.write("<br>"); 

                    document.write("You") ;// Second 
                    document.write("<br>"); 
                    document.write("<br>"); 
                    
                    document.write("New bill to pay!"); // Third 
                </script> 
                </pre> 
                <figcaption>
                    <span class="fig_cap_label">Пр. код 2.</span>
                    <span class="fig_cap_text">Резултат[<a href="#sources">7</a>]</span>
                </figcaption>                

                <p>Както може да видим, при изпълнението на горния код първоначално се изпълнява първият ред от кода: <strong>Hello,</strong>. Последван от втория: <strong>You</strong>. И след неговото завършване - третия: <strong>New bill to pay!</strong>
                </p>
                <h3><strong>Асинхронни заявки</strong></h3>
                <p>
                    Асинхронният код позволява части от програмата да бъдат изпълнявани веднага, докато синхрониият би блокирал по-нататъшно изпълнение на останалата част от кода, докато не приключи изпълнението на текущата. 
                    И дори това да не изглежда като чак толкова голям проблем, погледнато в една по-обща и голяма картина, би довело до значително и нежелано забавяне, рефлектиращо върху потребителския интерфейс.
                </p>
<pre>
    document.write("Hello!"); 
                
                  
    setTimeout(() => { 
        document.write("What happens here..."); 
        }, 2000); 
                  
                    
    document.write("Goodbye!");                    
</pre>   

<figcaption>
    <span class="fig_cap_label">Пр. код 3.</span>
    <span class="fig_cap_text">Отпечатване и функция setTimeout()[<a href="#sources">10</a>]</span>
</figcaption>  
                <p>
                    Така, ако изпълним този скрипт, ще видим, че това, което прави програмата е: изпълнява, както се очаква, първия ред от кода: <strong>Hello!</strong>, след което отпечатва реда с <strong>Goodbye!</strong> и накрая резултата от изпълнението на функцията <strong>setTimeout</strong>.
                    Тази функция се предава на web API за обработка, докато през това време изпълнението на останалия код продължава както обикновено.
                    По този начин тя не блокира останалата част от кода, докато приключи, а се добява към <span class="emphasized">call stack-а</span> и накрая бива изпълнена.
                    Това е възможно, благодарение на асинхронната обработка. 
                </p>                    

                <figure>
                    <img class="art" src="images/s-as-calls.webp">
                    <figcaption>
                        <span class="fig_cap_label">Фиг. 1.</span>
                        <span class="fig_cap_text">Синхронни и/или асинхронни процеси[<a href="#sources">10</a>]</span>
                    </figcaption>
                </figure>
                           
            </article>

            <article id="xhr">
                <h2>XHR</h2> 
                <p><span class="emphasized">XMLHttpRequests</span> или накратко <span class="emphasized">XHR</span> обектите 
                    се използват за асинхронно извличане на данни. Преди близо 14 години World Wide Web Консорциумът публикува спецификация на работния проект
                    за XHR. В ранните етапи XMLHttpRequests се използва за извличане на XML данни през HTTP, откъдето идва и името. 
                    Но в днешно време може да се използва и с протоколи, различни от HTTP, и да извлича данни не само в XML формат, но
                    също и JSON, HTML или plain text. 
                    Твърди се, че оригиналната идея зад XMLHttpRequests обектите произхожда от
                    създателите на Outlook Web Access(Microsoft). 
                    Следва примерен код, който да покаже принципа на работа на XHR:
                </p>
    <pre>
        function success() {
          var data = JSON.parse(this.responseText);
            console.log(data);
            }
    
        function error(err) {
            console.log('Error Occurred :', err);
            }
    
        var xhr = new XMLHttpRequest();
        xhr.onload = success;
        xhr.onerror = error;
        xhr.open('GET', 'https://api.github.com/users/swapnilbangare');
        xhr.send();
    </pre> 

    <figcaption>
        <span class="fig_cap_label">Пр. код 4.</span>
        <span class="fig_cap_text">XHR обекти[<a href="#sources">3</a>]</span>
    </figcaption>  

                    <p>
                    Нуждаем се от два слушателя, настроени да обработват съответно случаите на успех и грешка и от извикване на open() и send().
                    Резултатът от отговора на сървъра се съхранява в променливата responseText, която се конвертира до JavaScript обект, чрез JSON.parse().
                    <h4>Подробна информация за свойствата и методите на XHR обектите може да се намери <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest">тук.</a></h4>
                    Събитията, свързани с асинхронната обработка на данни чрез XHR са следните: 
                    <ul>
                        <li>abort - настъпва при прекъсване на заявката, например при извикване на XMLHttpRequest.abort()</li>
                        <br />
                        <li>error - настъпва при откриване на грешка</li>
                        <br />
                        <li>load - настъпва при успешно завършване на XMLHttpRequest транзакцията</li>
                        <br />
                        <li>loadend - настъпва след приключване на заявката, независимо дали успешно(след load()), или неуспешно(след abort() или error())</li>
                        <br />
                        <li>loadstart - настъпва, когато заявката започва да зарежда данните</li>
                        <br />
                        <li>progress - настъпва периодично, когато заявката получава още данни</li>
                        <br />
                        <li>timeout - настъпва при спиране на прогреса, поради изтичане на зададен времеви лимит</li>
                    <br />
                    В продължение на години XMLHTTPRequest се използва за изпращане, обработване и извличане на информация в различни формати от 
                    уеб браузър към сървър. Идва момента, в който се питаме: Дали няма по-чист и по-прост API за това?
                    Е, оказва се, че има. За да разберем, трябва да се върнем в бъдещето. 
                    <br />
                    <a href="#fetchapi"><h4 class="navigation">Завръщане в бъдещето</h4></a>
                    </p>             

            <article id="ajax">
                <h3>Преди и след AJAX</h3> 
                <p>
                    <p><h4>"Ще довърша по-късно!"</h4></p>
                    <img src="images/running.jpg">
                    <figcaption>
                        <span class="fig_cap_label">Фиг. 2.</span>
                        <span class="fig_cap_text">[<a href="https://www.google.com/search?q=running&tbm=isch&ved=2ahUKEwjq54qbpvbsAhVgDGMBHWETCUYQ2-cCegQIABAA&oq=running&gs_lcp=CgNpbWcQAzIECAAQQzIECAAQQzICCAAyAggAMgQIABBDMgIIADICCAAyAggAMgIIADICCABQ2LQEWNi0BGDVxgRoAHAAeACAAbQBiAG0AZIBAzAuMZgBAKABAaoBC2d3cy13aXotaW1nwAEB&sclient=img&ei=JKapX-rFH-CYjLsP4aaksAQ&client=ubuntu&hs=gGH#imgrc=cfwvWPWPXq70hM">Running</a>]</span>
                    </figcaption>
                    <br />
                    Преди да бъде представена <span class="emphasized">AJAX</span> или <span class="emphasized">Asynchronous JavaScript and XML</span> концепцията, за да се обнови
                    някаква част от дадена уеб страница, беше ноебходимо браузърите да правят заявка за цялата уеб страница и след получаването сървърът я обработваше чрез 
                    създаване и връщане на цяла страница към браузъра. Както вече споменахме по-горе, дори за една малка промяна
                    страницата се презарежда изцяло. А това е нежелано. Именно AJAX променя този традиционен начин на обновяване на уеб страница.
                    AJAX е техниката, чрез която уеб приложенията получават възможността да изпращат и извличат данни от сървъра асинхронно(в заден план) без това
                    променя визуализирането и поведението на съществуващата страница. Използва комбинация от:
                    <ul>
                        <br />
                        <li>XMLHttpRequest обект, вграден в браузъра(за заявка за данни към сървъра)</li>
                        <br />
                        <li>JavaScript и HTML DOM(за визуализиране и използване на данните)</li>
                    </ul>
                    <h4>Повече и интересна информация за <strong>DOM(Document Object Model) </strong>като стандарт за извличане, променяне, добавяне или триене на HTML елементи, може да намерите <a href="https://www.w3schools.com/js/js_htmldom.asp" target="_blank">тук.</a></h4> 
                    Основните стъпки в работата с данните са следните:
                    <ol>
                        <br />
                        <li>Появява се събитие на уеб страницата(страница е заредена или бутон е натиснат)</li>
                        <br />
                        <li>JavaScript създава XMLHttpRequest обект</li>
                        <br />
                        <li>XMLHttpRequest обектът изпраща заявка към сървъра</li>
                        <br />
                        <li>Сървърът обработва заявката</li>
                        <br />
                        <li>Сървърът изпраща отговор обратно към уеб страницата</li>
                        <br />
                        <li>Отговорът се прочита от JavaScript</li>
                        <br />
                        <li>JavaScript изпълнява подходящото действие(като например обновяване на страницата).</li>
                    </ol>
                    <figure>
                        <img class="art" src="images/ajax.gif">
                        <figcaption>
                            <span class="fig_cap_label">Фиг. 3.</span>
                            <span class="fig_cap_text">AJAX[<a href=#sources>7</a>]</span>
                        </figcaption>
                    </figure>
                </p>
            </article>

            <article id="callbacks">
                <h3>Callback функции</h3> 

                <p><h4>"Ще се обадя по-късно!"</h4></p>
                <img src="images/snowmen.png">
                <figcaption>
                    <span class="fig_cap_label">Фиг. 4.</span>
                    <span class="fig_cap_text">[<a href="https://www.google.com/search?q=I+will+call+back+later!&client=ubuntu&hs=nkl&channel=fs&sxsrf=ALeKk01IOBbNQluMQjg7DgkkVB9qlbIABQ:1604991377654&source=lnms&tbm=isch&sa=X&ved=2ahUKEwi31LrnsvfsAhVErxoKHf5kAyUQ_AUoAXoECA0QAw&biw=1294&bih=667#imgrc=0ETVKFeeP4lseM">Snowmen</a>]</span>
                </figcaption>
                <br />
                
                <p><span class="emphasized">Callback функциите</span> по същество са функции, които се подават като аргумент на други функции.
                Най-честата им употреба в практиката е при работата с асинхронни извиквания. Следният пример добре илюстрира концепцията, стояща зад callback функциите:
                </p>
<pre>
    function myDisplayer(some) {
        document.getElementById("demo").innerHTML = some;
      }
      
      function getFile(myCallback) {
        let req = new XMLHttpRequest();
        req.open('GET', "mycar.html");
        req.onload = function() {
          if (req.status == 200) {
            myCallback(this.responseText);
          } else {
            myCallback("Error: " + req.status);
          }
        }
        req.send();
      }
      
      getFile(myDisplayer);
</pre>   
<figcaption>
    <span class="fig_cap_label">Пр. код 5.</span>
    <span class="fig_cap_text">Callback функции[<a href="#sources">5</a>]</span>
</figcaption>  

                <p>
                    В този случай myDisplayer е използвана като callback функция. Името е предадено като аргумент на функцията getFile.
                    В нея се създава обект от тип XMLHTTPRequest, който отваря файла "mycar.html", зарежда функция и в зависимост от обработката
                    прави извикване на myCallBack функцията със съответния аргумент, след което изпраща резултата.

                    В повечето случаи функцията, която приема името на callback функция като параметър, "говори си" с някаква база данни, сваля файл, изпълнява API заявки или  
                    върши някаква друга работа, която може да блокира изпълнението на останалата част от кода за доста време.
                    Да си представим, че сваляме някаква снимка. Това обикновено отнема няколко секунди, но ние не искаме изпълнението на други заявки да спира, докато свалянето приключи.
                    Именно callback ще "извика" снимката, след като вече е свалена. 
                </p>

                <p>
                    С повечето сила идва и повече отговорност. В JavaScript като език няма някаква специална част, наречена callback. Те са просто една конвенция, позволяваща 
                    изпълнението на функционалностите, които споменахме. Те са функцци, на които всъщност им трябва някакво време, за да произведат резултат. Това е и смисълът на асинхронността.
                    Но в практиката при по-големи обработки на данни интуитивното им възприемане е далеч по трудно. В резултат от това може да се получат едни структури под формата на пирамидки с доста като брой вградени callback функции. 
                    Това всъщност наричат callback ад (callback hell). Следва един такъв пример, за да онагледи тази нежелана ситуация:
                </p>
<pre>
  fs.readdir(source, function (err, files) {
    if (err) {
        console.log('Error finding files: ' + err)
    } else {
        files.forEach(function (fn, fileIndex) {
        console.log(fn)
        gm(source + fn).size(function (err, values) {
            if (err) {
            console.log('Error identifying file size: ' + err)
            } else {
            console.log(fn + ' : ' + values)
            aspect = (values.w / values.h)
            ws.forEach(function (w, wIndex) {
                h = Math.round(w / aspect)
                console.log('res'+fn+'to'+h+'x'+ h)
                this.resize(w, h).write(d+'w'+w+'_'+fn, function(err) {
                if (err) console.log('Error writing file: ' + err)
                })
            }.bind(this))
            }
        })
        })
    }
    })
</pre>
<figcaption>
    <span class="fig_cap_label">Пр. код 6.</span>
    <span class="fig_cap_text">Callback hell[<a href="#sources">9</a>]</span>
</figcaption>  
                <p>
                    Причината за получаването на този callback ад е това, че хората опитват да пишат JavaScript по начин, където
                    изпълнението се случва от началото до края. В езици като C, Ruby или Python се очаква, че каквото се изпълнява на ред 1 ще приключи преди
                    частта от кода, която е на ред 2, да е започнала изпълнението си. И така до края на програмата. 
                    <br />
                    <strong>Бихме се запитали има ли начин да избегнем цялата тази бъркотия в работата и кода?</strong>
                    <br />
                    Има три правила, които може да се приложат, но въпреки това, резултатът силно зависи от контекста на ситуацията:
                    <ul>
                        <br />
                        <li>Пазим кода плитък</li>
                        <br />
                        <li>Модуларизираме(разделяме на отделни по смисъл части/модули)</li>
                        <br />
                        <li>Обработваме всяка грешка</li>
                        <br />
                    </ul>
                    Има цял един сайт, посветен на темата callback hell, дори и именуван по този начин.
                    <br />
                    Може да разгледате <a href="http://callbackhell.com/" target="_blank">тук.</a>
                    <p>
                    Едно съвременно и елегантно решение са т.нар. <a href=#promises class="navigation">Promises</a>, които ще разгледаме по-подробно след малко. 
                    </p>
                </p>
            </article>              

            <br />
            <p><h3>"Необходимостта е майка на всички изобретения."</h3></p>
            <br />
            <article id="fetchapi">
                <h2>Fetch API</h2> 
                
                <p><span class="emphasized">Fetch API</span> е нов и изцяло JavaScript API(Application Programming Interface), поддържан от повечето браузъри в днешно време.
                Това, което Fetch ни позволява, е да правим запитвания от браузъра към сървъра, подобни на тези с XMLHTTPRequest. Основната разлика е тази в представянето. Fetch е
                техника, чрез която тези асинхронни заявки и обработката им се случват по-бързо и по-леко в сравнение с по-старата XMLHTTPRequest техника, то е нейното подобрение.
                В начина на работа разликата е в това, че Fetch използва Promises, които подробно разглеждаме в следващия параграф, докато XHR ни оставя проблема на т.нар. callback ад(callback hell).
                Fetch API има следния интерфейс: 
                <ul>
                    <br />
                    <li>fetch() - методът се използва за извличане на ресурс</li>
                    <br />
                    <li>Headers - представляват Response/Request header-и(header-и за отговор и заявка), позволяващи ни да изпращаме запитвания към тях
                    и да предприемаме различни действия в зависимост от резултатите.</li>
                    <br />
                    <li>Request - представлява заявка към ресурс</li>
                    <br />
                    <li>Response - представлява отговора на заявката</li>
                    <br />
                </ul>
                <strong>Как правим заявка, изплозвайки <em>fetch()</em>?</strong>
                Всяка fetch() функция е достъпна през глобалния Window обект. Тя приема един задължителен аргумент- 
                пътят към ресурса, който искаме да извлечем. Връща обект от тип Promise, независимо дали е успешен, или не.    
                Ако заявката е успешна, then() функцията получава обект от тип Response, ако се е провалила, catch() функцията 
                получава обект error. 
                </p>
<pre>
    fetch('https://api.github.com/users/swapnilbangare')
  .then(function (response) {
    console.log(response);
    })
  .catch(function (err) {
    console.log("Something went wrong!", err);
    });
</pre>   

<figcaption>
    <span class="fig_cap_label">Пр. код 7.</span>
    <span class="fig_cap_text">fetch() функцията[<a href=#sources>5</a>]</span>
</figcaption> 
                <h4>Response обекти</h4>
                <p>
                    Както можем да видим в кода по-горе Fetch API се използва, за да се направи извикване към GitHub
                    и да се извлече информация за потребител. Когато Promise е уреден, връща обект от тип Response. Но, ако
                    опитаме да отпечатим същия този обект на конзолата, ще видим, че не съдържа информацията, която искаме. Той всъщност
                    съдържа информация за самия отговор. Ако искаме наистина да вземем данните, трябва да вземем съдържанието на този отговор.
                    В случая върнатият отговор ще има .json метод. Така че трябва да извикаме .json метода на променливата с отговора.
                    Но това връща обект от тип Promise, откъдето следва, че трябва да имаме във веригата още един .then()
                    метод, чрез който да достъпим желаните данни. Съответно .catch() методът се грижи за обработката на евентулано възникнали грешки. 
                </p>

                <h4>Headers обекти</h4>
                <p>
                    Headers обектите ни позволяват чрез Headers() конструктора да създаваме такива обекти. 
                    Един такъв обект е група от двойки от тип име-стойност(name-value pairs). 
                </p>

                <h4>Опции на fetch()</h4>
                <p>
                    fetch() методът може да приема незадължителен втори параметър, т.нар. init обект, чрез който
                    може да специфицираме заявката. 
                </p>

                <h4>Request обекти</h4>
                <p>
                    Request обектите представляват заявка към даден ресурс. Вместо да предаваме url-а на ресурса във 
                    fetch() извикването, може да създадем обект от тип заявка чрез Request() конструктора и да подадем това като
                    аргумент на fetch(). По този начин може да правим персонализирани заявки.  
                </p>
            </article> 
     
            <article id="promises">
                <h3>Promises</h3> 
                
                <p><h4>"Обещавам!"</h4></p>
                    <img src="images/promises.jpeg">
                    <figcaption>
                        <span class="fig_cap_label">Фиг. 5.</span>
                        <span class="fig_cap_text">[<a href="">Promise</a>]</span>
                    </figcaption>

                <p><span class="emphasized">Promise</span> е обект, който представлява нещо, което ще бъде достъпно в бъдещето.
                    Това нещо всъщност е някаква стойност. Promises позволяват вместо да чакаме дадена стойност, която искаме, да получим
                    нещо, което представлява определена моментна стойност, така че да можем да продължим с останалата част, докато в един момент
                    се върнем и използваме стойността, генерирана от promise-а.
                    Promises в основата си работят със събития във времето и затова има набор от състояния, които
                    класифицират тези събития: 
                    <ul>
                        <br />
                        <li>Pending(в очакване) - преди да настъпи събитието</li>
                        <br />
                        <li>Resolves/Settled(Уредени) - след настъпване на събитието</li>
                        <br />
                        <li>Fullfiled(Успешни) - след приключване и връщане на правилния резултат</li>
                        <br />
                        <li>Rejected(Отхвърлени) - след приключване, но правилният резултат не е върнат</li>
                        <br />
                    </ul>
                </p>
                <p>
                    <strong>Какво може да правим с Promises?</strong>
                    <br />
                    Да произвеждаме(produce) и да потребяваме(consume) Promises в нашия код.
                    Когато произвеждаме Promise, ние създаваме нов обект от тип Promise и чрез него изпращаме даден резултат.
                    Когато потребяваме Promise, използваме callback функции, чрез които обработваме съответния резултат - в успешните(fullfiled) и 
                    отхвърлените(rejected) състояния. Всеки Promise наследява два основни метода - then() и catch().
                    Методът <span class="emphasized">then()</span> от върнатия обект ни позволява да добавим обработчик 
                    на събития, т.нар. event hadler, когато нашият Promise достигне до състояние на успех, тоест при връщане
                    на резултат от "resolve" функцията.
                    Методът <span class="emphasized">catch()</span> работи по същия начин, само че връщаният резултат е от "reject" функцията.
                    Promises имат едно голямо предимство, наречено <span class="emphasized">chaining</span>. С chaining можем просто да добавим още един 
                    then() след всеки then(). Това ни дава един много добър контрол върху нашата верига от уредени Promises. 
                </p>
                <p>
                    Колкото и удобни и магически да изглеждат Promises, остава възможността отново да попаднем в ситуацията
                    callback hell. Така кодът ни би станал почти нечетим и труден за поддръжка. 
                    Стига да следим и взимаме предвид добрите практики в имплементацията, Promises са едно средство, което
                    помага за добрата четимост на кода, свързан с асинхронните заявки. Ще обърнем внимание на една техника, която ни дава една
                    алтернативна възможност да потребяваме Promises, имплеметирана в ES2017<a href="https://en.wikipedia.org/wiki/ECMAScript" tarhet="_blank">(ECMAScript)</a>2017, а именно Async/Await.  
                </p>
            </article>    
            
            <article id="asyncawait">
                <h3>Aync/Await</h3> 
                
                <p><span class="emphasized">Async/Await</span> е възможност за работа с Promises, която ни позволява да пишем Promises, които са основани
                    на асинхронен код, но правят асинхронния код да изглежда и да се държи до голяма степен като синхронен. 
                    Чрез ключовата дума <strong>async</strong> създаваме асинхронна функция, което ознчава, че тя ще работи във фонов режим.
                    Вътре в самата async функция може да имаме няколко <strong>await</strong> функции(пред тях стои ключовата дума await). По този начин
                    изчакваме да бъде върнат вече уредения резултат от съответния Promise. Async функциите връщат обект от тип Promise. Това означава, 
                    че, за да достъпим резултата, трябва да използваме методът then(), който всеки Promise има. 
                </p>
            </article>   
            
            <article id="conclusion">
                <h2>Обобщение</h2> 

                <img src="images/fetch.jpeg">
                <figcaption>
                    <span class="fig_cap_label">Фиг. 6.</span>
                    <span class="fig_cap_text">[<a href="">fetch()</a>]</span>
                </figcaption> 

                <p>
                    Да обобщим, първоначалният замисъл и идея за използване на <span class="emphasized">XMLHTTPRequests</span> определено не са били 
                    пряко за нещата, които използваме днес. И в някои случаи неговият API с право може да ни се стори 
                    доста объркващ. <span class="emphasized">FETCH API</span> ни предла един по-лек и изчистен начин да правим асинхронни заявки и да обработваме отговорите.
                    Fetch дава възможност да се създаде далеч по-добър API като се използват съвременни елементи на JavaScript, каквито са Prmoises.  
                </p>
            </article>         
            
            <article id="sources">
                <h2>Използвана литература</h2>
<pre class="sr">
 [1] The Fetch API. A modern replacement for XMLHttpRequest,
 [<a href="https://medium.com/beginners-guide-to-mobile-web-development/the-fetch-api-2c962591f5c">https://medium.com/beginners-guide-to-mobile-web-development/the-fetch-api-2c962591f5c</a>], 
 последно посетен на 2020-11-10 
</pre>

<pre class="sr">
 [2] Fetch API-Web APIs|MDN,
 [<a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API</a>], 
 последно песетен на 2020-11-10
</pre>   

<pre class="sr">
 [3] XMLHTTPRequest-Web APIs|MDN, 
 [<a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest">https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest</a>], 
 последно песетен на 2020-11-10
</pre>   

<pre class="sr">
 [4] Introduction to fetch(), 
 [<a href="https://developers.google.com/web/updates/2015/03/introduction-to-fetch">https://developers.google.com/web/updates/2015/03/introduction-to-fetch</a>], 
 последно песетен на 2020-11-10
</pre>  

<pre class="sr">
 [5] JavaScript Async, 
 [<a href="https://www.w3schools.com/js/js_async.asp">https://www.w3schools.com/js/js_async.asp</a>], 
 последно песетен на 2020-11-10
</pre>  

<pre class="sr">
 [6] ECMAScript-Wikipedia, 
 [<a href="https://en.wikipedia.org/wiki/ECMAScript">https://en.wikipedia.org/wiki/ECMAScript</a>], 
 последно песетен на 2020-11-10
</pre>  

<pre class="sr">
 [7] AJAX Introduction, 
 [<a href="https://www.w3schools.com/xml/ajax_intro.asp">https://www.w3schools.com/xml/ajax_intro.asp</a>], 
 последно песетен на 2020-11-10
</pre> 

<pre class="sr">
 [8] Callbach Hell, Promises and Async/Await  
 [<a href="https://www.w3schools.com/xml/ajax_intro.asp">https://www.w3schools.com/xml/ajax_intro.asp</a>], 
 последно песетен на 2020-11-10
</pre> 

<pre class="sr">
 [9] Callback Hell 
 [<a href="http://callbackhell.com/">http://callbackhell.com/</a>], 
 последно песетен на 2020-11-10
</pre> 

<pre class="sr">
 [10] Synchronous vs. Asynchronous Request Handling|Trigent-Vintage
 [<a href="https://blog.trigent.com/synchronous-vs-asynchronous-request-handling/">https://blog.trigent.com/synchronous-vs-asynchronous-request-handling/</a>],
</pre> 

            <article  id="author">
                            <h2>Автор</h2>
                            <ul class="aut">
                                <li>E-mail: vladislavam1996@gmail.com</li>
                                <li>ФН: 81271</li>
                                <li>спец. Компютърни науки, IV курс, II поток</li>
                                <li>курс: Web технологии</li>
                                <li>лектор: доц. Милен Петров</li>
                                <li>2020 г.</li>
                            </ul>	
            </article>     
        </div>
    </body>
</html>